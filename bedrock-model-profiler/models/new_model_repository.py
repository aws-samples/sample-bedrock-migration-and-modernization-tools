"""
Repository for managing Bedrock model data with JSON structure.

This module provides a model repository that works with the hierarchical
JSON structure generated by amazon-bedrock-model-collector.
"""
import json
import os
import pandas as pd
from typing import Dict, List, Any, Optional
from datetime import datetime
import shutil


class NewModelRepository:
    """Repository for managing Bedrock model data with hierarchical structure"""

    def __init__(self, data_dir: str = 'data'):
        """Initialize the repository with the data directory"""
        self.data_dir = data_dir
        self.data_file = os.path.join(data_dir, 'bedrock_models.json')
        self.pricing_collector_path = 'collectors/pricing-collector/out'

        # Ensure data directory exists
        os.makedirs(data_dir, exist_ok=True)

    def load_raw_data(self) -> Dict[str, Any]:
        """Load the raw JSON data"""
        try:
            with open(self.data_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            return {}
        except Exception as e:
            print(f"Error loading raw data: {e}")
            return {}

    def load_pricing_data(self) -> Dict[str, Any]:
        """Load the separate pricing data file"""
        try:
            # Find the latest pricing file
            pricing_files = []
            if os.path.exists(self.pricing_collector_path):
                for file in os.listdir(self.pricing_collector_path):
                    if file.startswith('bedrock-pricing-') and file.endswith('.json'):
                        pricing_files.append(os.path.join(self.pricing_collector_path, file))

            if not pricing_files:
                print("No pricing files found")
                return {}

            # Use the latest pricing file
            latest_pricing_file = max(pricing_files, key=os.path.getmtime)

            with open(latest_pricing_file, 'r', encoding='utf-8') as f:
                return json.load(f)

        except Exception as e:
            print(f"Error loading pricing data: {e}")
            return {}

    def get_model_pricing_details(self, pricing_reference: Dict[str, Any]) -> Dict[str, Any]:
        """Get detailed pricing information for a model using its pricing reference"""
        try:
            if not pricing_reference.get('is_pricing_available'):
                return {}

            pricing_data = self.load_pricing_data()
            if not pricing_data:
                return {}

            file_ref = pricing_reference.get('pricing_file_reference', {})
            provider = file_ref.get('provider')
            model_key = file_ref.get('model_key')

            if not provider or not model_key:
                return {}

            # Navigate to the pricing data: providers > provider > model_key
            providers = pricing_data.get('providers', {})
            if provider in providers and model_key in providers[provider]:
                return providers[provider][model_key]

            return {}

        except Exception as e:
            print(f"Error getting pricing details: {e}")
            return {}

    def flatten_models_from_new_structure(self, data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Convert the hierarchical JSON structure to a flat list of models.

        Structure: data['providers'][provider_name]['models'][model_key] = model_data
        Output: list of model dictionaries
        """
        flattened_models = []

        if 'providers' not in data:
            return flattened_models

        for provider_name, provider_data in data['providers'].items():
            if 'models' not in provider_data:
                continue

            for model_key, model_data in provider_data['models'].items():
                # Create a flattened model entry
                flattened_model = model_data.copy()  # Start with all model data

                # Ensure correct identifiers - use from model_data if available, fallback to key
                if 'model_id' not in flattened_model:
                    flattened_model['model_id'] = model_key
                if 'model_name' not in flattened_model:
                    flattened_model['model_name'] = model_key
                if 'model_provider' not in flattened_model:
                    flattened_model['model_provider'] = provider_name

                # Ensure compatibility with old structure field names
                if 'provider' not in flattened_model:
                    flattened_model['provider'] = provider_name
                if 'name' not in flattened_model and 'model_name' in flattened_model:
                    flattened_model['name'] = flattened_model['model_name']

                # Handle description field - it might be nested or missing
                if 'description' not in flattened_model or not flattened_model.get('description'):
                    # Try to get description from nested structure
                    model_desc = model_data.get('model_description', {})
                    desc_text = ""

                    if isinstance(model_desc, dict):
                        desc_text = model_desc.get('description', '') or model_desc.get('overview', '') or model_desc.get('summary', '')
                    elif isinstance(model_desc, str) and model_desc.strip():
                        desc_text = model_desc.strip()

                    # If still no description, try other fields
                    if not desc_text:
                        # Try model use cases
                        use_cases = flattened_model.get('model_use_cases', [])
                        if isinstance(use_cases, list) and use_cases:
                            desc_text = f"Supports {', '.join(use_cases[:3])}"

                        # Try model capabilities
                        elif 'model_capabilities' in flattened_model:
                            capabilities = flattened_model.get('model_capabilities', [])
                            if isinstance(capabilities, list) and capabilities:
                                desc_text = f"Capabilities: {', '.join(capabilities[:2])}"

                        # Try modalities
                        elif 'model_modalities' in flattened_model:
                            modalities = flattened_model.get('model_modalities', [])
                            if isinstance(modalities, list) and modalities:
                                desc_text = f"Supports {', '.join(modalities)} processing"

                    # Final fallback with provider and model info
                    if not desc_text:
                        model_name = flattened_model.get('model_name', model_key)
                        desc_text = f"{model_name} - {provider_name} foundation model"

                    flattened_model['description'] = desc_text

                # Ensure pricing information is available
                if 'model_pricing' in flattened_model:
                    pricing_info = flattened_model['model_pricing']
                    if pricing_info.get('is_pricing_available'):
                        # Load detailed pricing if available
                        detailed_pricing = self.get_model_pricing_details(pricing_info)
                        if detailed_pricing:
                            flattened_model['detailed_pricing'] = detailed_pricing

                # Extract regions from cross_region_inference if available
                if 'regions' not in flattened_model or not flattened_model['regions']:
                    cross_region_inference = flattened_model.get('cross_region_inference', {})
                    if isinstance(cross_region_inference, dict):
                        # Use destination_regions as they represent all regions where model can be accessed
                        destination_regions = cross_region_inference.get('destination_regions', [])
                        source_regions = cross_region_inference.get('source_regions', [])

                        # Combine both and deduplicate
                        all_regions = list(set(destination_regions + source_regions))
                        if all_regions:
                            flattened_model['regions'] = sorted(all_regions)

                flattened_models.append(flattened_model)

        return flattened_models

    def load_models_df(self) -> pd.DataFrame:
        """Load models as a pandas DataFrame with the new structure"""
        try:
            data = self.load_raw_data()

            if not data:
                return pd.DataFrame()

            # Handle both old and new structures
            if 'models' in data and isinstance(data['models'], list):
                # Old structure - direct list of models
                return pd.DataFrame(data['models'])
            elif 'providers' in data:
                # Hierarchical structure by provider
                flattened_models = self.flatten_models_from_new_structure(data)
                return pd.DataFrame(flattened_models)
            else:
                return pd.DataFrame()

        except Exception as e:
            print(f"Error loading models DataFrame: {e}")
            return pd.DataFrame()

    def get_metadata(self) -> Dict[str, Any]:
        """Get metadata from the data file"""
        try:
            data = self.load_raw_data()
            return data.get('metadata', {})
        except Exception as e:
            print(f"Error loading metadata: {e}")
            return {}

    def get_providers(self) -> List[str]:
        """Get list of all providers"""
        try:
            data = self.load_raw_data()
            if 'providers' in data:
                return list(data['providers'].keys())
            else:
                # Fallback to metadata
                metadata = self.get_metadata()
                return metadata.get('providers', [])
        except Exception as e:
            print(f"Error getting providers: {e}")
            return []

    def get_models_by_provider(self, provider: str) -> pd.DataFrame:
        """Get models for a specific provider"""
        try:
            df = self.load_models_df()
            if df.empty:
                return pd.DataFrame()

            return df[df['provider'] == provider]
        except Exception as e:
            print(f"Error getting models by provider: {e}")
            return pd.DataFrame()

    def get_model_details(self, model_id: str) -> Dict[str, Any]:
        """Get detailed information for a specific model with pricing data"""
        try:
            data = self.load_raw_data()

            # Search in hierarchical structure
            if 'providers' in data:
                for provider_name, provider_data in data['providers'].items():
                    if 'models' in provider_data and model_id in provider_data['models']:
                        model_data = provider_data['models'][model_id].copy()
                        model_data['provider'] = provider_name
                        model_data['model_id'] = model_id

                        # Add pricing information if available
                        if 'model_pricing' in model_data:
                            pricing_info = model_data['model_pricing']
                            if pricing_info.get('is_pricing_available'):
                                detailed_pricing = self.get_model_pricing_details(pricing_info)
                                if detailed_pricing:
                                    model_data['detailed_pricing'] = detailed_pricing

                        # Handle description with robust fallback
                        if 'description' not in model_data or not model_data.get('description'):
                            model_desc = model_data.get('model_description', {})
                            desc_text = ""

                            if isinstance(model_desc, dict):
                                desc_text = model_desc.get('description', '') or model_desc.get('overview', '') or model_desc.get('summary', '')
                            elif isinstance(model_desc, str) and model_desc.strip():
                                desc_text = model_desc.strip()

                            # If still no description, try other fields
                            if not desc_text:
                                # Try model use cases
                                use_cases = model_data.get('model_use_cases', [])
                                if isinstance(use_cases, list) and use_cases:
                                    desc_text = f"Supports {', '.join(use_cases[:3])}"

                                # Try model capabilities
                                elif 'model_capabilities' in model_data:
                                    capabilities = model_data.get('model_capabilities', [])
                                    if isinstance(capabilities, list) and capabilities:
                                        desc_text = f"Capabilities: {', '.join(capabilities[:2])}"

                                # Try modalities
                                elif 'model_modalities' in model_data:
                                    modalities = model_data.get('model_modalities', [])
                                    if isinstance(modalities, list) and modalities:
                                        desc_text = f"Supports {', '.join(modalities)} processing"

                            # Final fallback
                            if not desc_text:
                                model_name = model_data.get('model_name', model_id)
                                desc_text = f"{model_name} - {provider_name} foundation model"

                            model_data['description'] = desc_text

                        return model_data

            # Search in old structure (fallback)
            df = self.load_models_df()
            if not df.empty:
                model_rows = df[df['model_id'] == model_id]
                if not model_rows.empty:
                    return model_rows.iloc[0].to_dict()

            return {}
        except Exception as e:
            print(f"Error getting model details: {e}")
            return {}

    def search_models(self, query: str, fields: List[str] = None) -> pd.DataFrame:
        """Search models by query string in specified fields"""
        try:
            df = self.load_models_df()
            if df.empty:
                return pd.DataFrame()

            if fields is None:
                fields = ['model_id', 'model_name', 'provider', 'description']

            # Filter to only existing fields
            existing_fields = [field for field in fields if field in df.columns]

            if not existing_fields:
                return pd.DataFrame()

            # Search in each field
            mask = pd.Series(False, index=df.index)
            query_lower = query.lower()

            for field in existing_fields:
                if field in df.columns:
                    field_mask = df[field].astype(str).str.lower().str.contains(query_lower, na=False)
                    mask = mask | field_mask

            return df[mask]
        except Exception as e:
            print(f"Error searching models: {e}")
            return pd.DataFrame()

    def get_statistics(self) -> Dict[str, Any]:
        """Get basic statistics about the model data"""
        try:
            data = self.load_raw_data()
            df = self.load_models_df()

            metadata = self.get_metadata()

            stats = {
                'total_models': len(df) if not df.empty else metadata.get('total_models', 0),
                'total_providers': df['provider'].nunique() if not df.empty else metadata.get('providers_count', 0),
                'last_updated': metadata.get('generated_at', 'Unknown'),
                'version': metadata.get('version', 'Unknown'),
                'regions_covered': metadata.get('regions_covered', 0),
                'models_with_pricing': metadata.get('models_with_pricing', 0),
                'models_with_quotas': metadata.get('models_with_quotas', 0)
            }

            if not df.empty:
                # Add more detailed statistics from the actual data
                if 'regions' in df.columns:
                    all_regions = []
                    for regions in df['regions'].dropna():
                        if isinstance(regions, list):
                            all_regions.extend(regions)
                    stats['unique_regions'] = len(set(all_regions))

                if 'capabilities' in df.columns:
                    all_capabilities = []
                    for capabilities in df['capabilities'].dropna():
                        if isinstance(capabilities, list):
                            all_capabilities.extend(capabilities)
                    stats['unique_capabilities'] = len(set(all_capabilities))

            return stats
        except Exception as e:
            print(f"Error getting statistics: {e}")
            return {}

    def _create_backup(self):
        """Create a backup of the current data file"""
        if os.path.exists(self.data_file):
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            backup_file = os.path.join(self.data_dir, f'bedrock_models_backup_{timestamp}.json')
            shutil.copy2(self.data_file, backup_file)
            print(f"Backup created: {backup_file}")


# For backward compatibility, we can also create an alias
ModelRepository = NewModelRepository